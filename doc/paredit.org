#+title: paredit-mode

编辑lisp语言(及其类似语言)的很好用的工具
* Opening(键入一队新的"括号")
   + =(= -> =paradit-open-round=
   + =[= -> =paredit-open-square=
   + ={= -> =paredit-open-curly=
   + =paredit-open-angled= (默认不开启)
   在键入这些字符时,括号成对出现
* Closing and indenting 
   每个open函数有对应的 =paredit-close-xxx= 在键入')','}',']'时会自动对齐.
   #+BEGIN_SRC emacs-lisp
   (defun test ()                (defun test ()
          (do-somthing)_    ==>         (do-something))
          )
   ;;; 下划线代表光标位置,这里键入')'
   #+END_SRC

* Quoting
   paredit对待"和括号一样 =paredit-doublequote=
   + 不再引号内的地方输入",open或close一个引号
   + 在引号内字符串尾输入",跳出字符串
   + 在引号其他地方输入,会得到转义的\"
* Wrapping an S-expression
   - =M-(= -> =paredit-wrap-round=
   - =M-"= -> =paredit-meta-doublequote= 
   将后面的一个S-exp用(或"包围起来(会自动转义)
   #+BEGIN_SRC emacs-lisp
   _a-string       ==> "a-string"  ;; M-"
   _"a-string"     ==> "\"a-string\"" ;; M-"
   _"\"a-string\"" ==> ("\"a-string\"") ;; M-(
   #+END_SRC

* Deleting
   - =C-d=, =DEL= -> =paredit-forward-delete=
   - =M-d= -> =paredit-forward-kill-word=
   - =C-DEL= -> =paredit-backward-kill-word= (默认是 =M-DEL= 我更改键位)
   - =C-k= -> =paredit-kill=
   以上所有的删除操作总是把持括号平衡

* Slurping and Barfing
   - =C-)= -> =paredit-forward-slurp-sexp=
   - =C-(= -> =paredit-backward-slurp-sexp=
   将前一个或后一个S-exp吸收进括号
   #+BEGIN_SRC emacs-lisp
   (defun test (bar_) foo foo)  ==> (defun test (bar foo) foo) ;; C-)
   (defun test (_bar) foo foo)  ==> (defun (test bar) foo foo) ;; C-(
   #+END_SRC
   - =C-}= -> =paredit-forward-barf-sexp=
   - =C-{= -> =preadit-backward-barf-sexp=
   将括号中最后一个或第一个S-exp挤出括号
   #+BEGIN_SRC emacs-lisp
   (defun (_test bar) foo foo)  ==> (defun test (bar) foo foo) ;; C-{
   (defun test (bar foo_) foo)  ==> (defun test (bar) foo foo) ;; C-}
   #+END_SRC

* Navigation
   共有6个在括号层次间跳转函数(快捷键都改动了)
   - =C-.= -> =paredit-forward=
   - =C-,= -> =paredit-backward=
   - =M-[= -> =paredit-backward-down=
   - =M-]= -> =paredit-forward-down=
   - =M-n= -> =paredit-forward-up=
   - =M-p= -> =paredit-backward-up=
   up是上一层括号,down是下一层括号
   #+BEGIN_SRC emacs-lisp
   (defun_ (test) ) ==> (defun (test)_ ) ;; C-.
   (defun (test)_ ) ==> (defun_ (test) ) ;; C-,
   (defun_ (test) ) ==> (defun (_test) ) ;; M-]
   (defun (test) _) ==> (defun (test_) ) ;; M-[
   (defun (test_) ) ==> (defun (test) _) ;; M-n
   (defun (test_) ) ==> (defun _(test) ) ;; M-p
   #+END_SRC

* Splice
   - =M-<up>= -> =paredit-splice-kill-backward=
   - =M-<down>= -> =paredit-splice-kill-forward=
   - =M-s= -> =paredit-splice=
   去掉当前S-exp的括号,kill-backward是删除该S-exp中光标前的内容留下之后的,
   kill-forward相反.
   #+BEGIN_SRC emacs-lisp
   (defun test ()                 (defun test ()
       (let (a b) _      ==>          let (a b) _
            (list a b)))                  (list a b))   ;; M-s

   (defun test ()                 (defun test ()
       (let (a b) _      ==>         _(list a b))
            (list a b)))                                ;; M-<up>

   (defun test ()                 (defun test ()
       (let (a b) _      ==>          let (a b)_) 
            (list a b)))                                ;; M-s

   #+END_SRC

* Split and Join
   - =M-S= -> =paredit-split-sexp=
   - =M-J= -> =paredit-join-sexps=
   拆分和连接S-exp
   #+BEGIN_SRC emacs-lisp
   (print "Thanks _ for reading") ==> (print "Thanks "_" for reading")   ;; M-S
                                  ==> (print "Thanks ")_(" for reading") ;; M-S
                                  ==> (print "Thanks "_" for reading")   ;; M-J
   #+END_SRC

* Bonus
   这是一个很奇妙的命令
   - =M-?= -> =paredit-convolute-sexp=
   这个指令含义是:
   - 执行 =paredit-splice-kill-backward= 但是保存删去的sexp
   - 前缀参数N(默认是1),向上移动N层列表
   - 把删去的sexp(作为前缀)和目前的sexp连接成新的表
   #+BEGIN_SRC emacs-lisp
   (defun test ()            (defun test ()   
     (let (a b)         ==>      (list (let (a b)
       (list _a b)))                    a b)))        ;; M-?

   (defun test ()            (list (defun test ()   
     (let (a b)         ==>           (let (a b)
       (list _a b)))                        a b)))    ;; C-2 M-?

   #+END_SRC

* Raise
   =M-r= -> =paredit-raise-sexp=
   将光标后的一个S-exp代替光标所在的整个S-exp
   #+BEGIN_SRC emacs-lisp
   (defun test ()            (defun test ()
     (let (a b) _       ==>      (list a b))    ;; M-r
       (list a b))))    
   #+END_SRC

